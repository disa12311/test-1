stages:
  - maintenance

# Job to close stale issues
close_stale_issues:
  stage: maintenance
  image: python:3.11-slim
  
  # Run daily at 00:00 UTC
  # Can also be triggered manually from CI/CD ‚Üí Pipelines
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_PIPELINE_SOURCE == "web"  # Allows manual trigger
  
  variables:
    # === ISSUE CONFIGURATION ===
    
    # Days of inactivity before closing (7 days as requested)
    DAYS_BEFORE_CLOSE: "7"   # Close after 7 days of inactivity (no stale phase)
    
    # Label to add when closing (optional)
    CLOSE_LABEL: "closed-due-to-inactivity"
    
    # === EXEMPTIONS ===
    
    # Issues with these labels will NEVER be closed
    EXEMPT_LABELS: "pinned,security,keep-open,bug,enhancement,feature-request"
    
    # Exempt issues with assignees (false = assigned issues CAN be closed)
    EXEMPT_ASSIGNEES: "false"
    
    # Exempt issues with milestones (true = issues in milestones won't be closed)
    EXEMPT_MILESTONES: "true"
    
    # === PERFORMANCE ===
    
    # Maximum number of operations per run (prevents rate limiting)
    MAX_OPERATIONS: "100"
  
  before_script:
    - pip install --quiet requests python-dateutil
  
  script:
    - python3 << 'EOF'
      import os
      import requests
      from datetime import datetime, timedelta
      from dateutil import parser
      import time

      # Configuration
      GITLAB_TOKEN = os.environ.get('GITLAB_TOKEN')
      PROJECT_ID = os.environ.get('CI_PROJECT_ID')
      GITLAB_URL = os.environ.get('CI_API_V4_URL')
      
      DAYS_BEFORE_CLOSE = int(os.environ.get('DAYS_BEFORE_CLOSE', 7))
      CLOSE_LABEL = os.environ.get('CLOSE_LABEL', 'closed-due-to-inactivity')
      EXEMPT_LABELS = [label.strip() for label in os.environ.get('EXEMPT_LABELS', '').split(',') if label.strip()]
      EXEMPT_ASSIGNEES = os.environ.get('EXEMPT_ASSIGNEES', 'false').lower() == 'true'
      EXEMPT_MILESTONES = os.environ.get('EXEMPT_MILESTONES', 'true').lower() == 'true'
      MAX_OPERATIONS = int(os.environ.get('MAX_OPERATIONS', 100))
      
      headers = {
          'PRIVATE-TOKEN': GITLAB_TOKEN,
          'Content-Type': 'application/json'
      }
      
      def get_all_open_issues():
          """Fetch all open issues from the project"""
          issues = []
          page = 1
          per_page = 100
          
          while True:
              url = f"{GITLAB_URL}/projects/{PROJECT_ID}/issues"
              params = {
                  'state': 'opened',
                  'per_page': per_page,
                  'page': page,
                  'order_by': 'updated_at',
                  'sort': 'asc'
              }
              
              response = requests.get(url, headers=headers, params=params)
              
              if response.status_code != 200:
                  print(f"‚ùå Error fetching issues: {response.status_code}")
                  break
              
              batch = response.json()
              if not batch:
                  break
                  
              issues.extend(batch)
              page += 1
              time.sleep(0.5)  # Rate limiting
          
          return issues
      
      def has_exempt_label(issue):
          """Check if issue has any exempt labels"""
          issue_labels = issue.get('labels', [])
          for label in EXEMPT_LABELS:
              if label in issue_labels:
                  return True
          return False
      
      def has_assignees(issue):
          """Check if issue has assignees"""
          return len(issue.get('assignees', [])) > 0
      
      def has_milestone(issue):
          """Check if issue has a milestone"""
          return issue.get('milestone') is not None
      
      def close_issue(issue_iid, comment):
          """Close an issue with a comment"""
          # Add comment
          comment_url = f"{GITLAB_URL}/projects/{PROJECT_ID}/issues/{issue_iid}/notes"
          requests.post(comment_url, headers=headers, json={'body': comment})
          time.sleep(0.3)
          
          # Get current labels
          issue_url = f"{GITLAB_URL}/projects/{PROJECT_ID}/issues/{issue_iid}"
          issue_data = requests.get(issue_url, headers=headers).json()
          current_labels = issue_data.get('labels', [])
          
          # Add close label if not already present
          if CLOSE_LABEL not in current_labels:
              current_labels.append(CLOSE_LABEL)
          
          # Close issue and update labels
          data = {
              'state_event': 'close',
              'labels': ','.join(current_labels)
          }
          response = requests.put(issue_url, headers=headers, json=data)
          
          return response.status_code == 200
      
      # Main logic
      print("="*60)
      print("ü§ñ GitLab Stale Issues Bot")
      print("="*60)
      print(f"üîç Fetching open issues from project {PROJECT_ID}...")
      
      issues = get_all_open_issues()
      print(f"üìä Found {len(issues)} open issues\n")
      
      now = datetime.now(datetime.now().astimezone().tzinfo)
      close_threshold = now - timedelta(days=DAYS_BEFORE_CLOSE)
      
      closed_count = 0
      skipped_count = 0
      operations = 0
      
      print(f"‚öôÔ∏è  Configuration:")
      print(f"   ‚Ä¢ Close after: {DAYS_BEFORE_CLOSE} days of inactivity")
      print(f"   ‚Ä¢ Exempt labels: {', '.join(EXEMPT_LABELS) if EXEMPT_LABELS else 'None'}")
      print(f"   ‚Ä¢ Exempt assignees: {EXEMPT_ASSIGNEES}")
      print(f"   ‚Ä¢ Exempt milestones: {EXEMPT_MILESTONES}")
      print(f"   ‚Ä¢ Max operations: {MAX_OPERATIONS}\n")
      
      for issue in issues:
          if operations >= MAX_OPERATIONS:
              print(f"\n‚ö†Ô∏è  Reached maximum operations limit ({MAX_OPERATIONS})")
              break
          
          iid = issue['iid']
          title = issue['title']
          updated_at = parser.parse(issue['updated_at'])
          
          # Check exemptions
          skip_reasons = []
          
          if has_exempt_label(issue):
              skip_reasons.append("exempt label")
          
          if EXEMPT_ASSIGNEES and has_assignees(issue):
              skip_reasons.append("has assignees")
          
          if EXEMPT_MILESTONES and has_milestone(issue):
              skip_reasons.append("has milestone")
          
          if skip_reasons:
              skipped_count += 1
              print(f"‚è≠Ô∏è  Skipped #{iid}: {title[:50]}... ({', '.join(skip_reasons)})")
              continue
          
          # Check if should be closed
          if updated_at < close_threshold:
              days_inactive = (now - updated_at).days
              print(f"üîí Closing issue #{iid} (inactive for {days_inactive} days)")
              print(f"   Title: {title[:60]}...")
              
              close_comment = """This issue has been automatically closed due to inactivity.

If you believe this issue still needs attention, feel free to reopen it or create a new issue with updated information.

Thank you for your contribution!"""
              
              if close_issue(iid, close_comment):
                  closed_count += 1
                  operations += 2  # Comment + close = 2 operations
                  print(f"   ‚úÖ Successfully closed\n")
              else:
                  print(f"   ‚ùå Failed to close\n")
              
              time.sleep(1)  # Rate limiting
      
      # Summary
      print("="*60)
      print("üìà Summary:")
      print(f"   ‚Ä¢ Total open issues: {len(issues)}")
      print(f"   ‚Ä¢ Closed: {closed_count}")
      print(f"   ‚Ä¢ Skipped (exempt): {skipped_count}")
      print(f"   ‚Ä¢ Operations used: {operations}/{MAX_OPERATIONS}")
      print("="*60)
      
      if closed_count > 0:
          print(f"‚úÖ Successfully closed {closed_count} stale issue(s)")
      else:
          print("‚ú® No stale issues found")
      EOF

  only:
    variables:
      - $GITLAB_TOKEN  # Only run if token is available